Access Control (Authorization)
******************************

.[perex]
Authorization determines whether a user has sufficient privileges, for example, to access a specific resource or to perform an action. Authorization assumes previous successful authentication, ie that the user is logged in.

Nette Framework authorization may be based on what groups the user belongs to or on which roles were assigned to the user. We will start from the very beginning.

For simple web sites with administration, where all users share the same privileges, it is sufficient to use already mentioned `isLoggedIn()` method. Simply put, if the user is logged in, he has permissions to all actions and vice versa.

```php
if ($user->isLoggedIn()) { // is user logged in?
	deleteItem(); // if so, he may delete an item
}
```


Roles
-----

The purpose of roles is to offer a more precise privilege control while remaining independent on the user name. As soon as user logs in, he is assigned one or more roles. Roles themselves may be simple strings, such as `admin`, `member`, `guest`, etc. They are specified in the second argument of `Identity` constructor, either as a string or an array.

This time we will use the `isInRole()` method to check if the user is allowed to perform some action:

```php
if ($user->isInRole('admin')) { // is the admin role assigned to the user?
	deleteItem(); // if so, he may delete an item
}
```

As you already know, logging the user out does not erase his identity. Therefore the `getIdentity()` method still returns an `Identity` object, with all the assigned roles regardless of logout. Nette Framework adheres to the "less code, more security" principle, which is why it doesn't want to force coders to write `if ($user->isLoggedIn() && $user->isInRole('admin'))` everywhere and therefore the `isInRole()` method works with **effective roles**. If the user is logged in, roles assigned to identity are used, if he is logged out, an automatic special role `guest` is used instead.


Authorizator
------------

Authorizator decides whether the user has permission to take some action. It's an implementation of [api:Nette\Security\IAuthorizator] interface with only one method `isAllowed()`. The purpose of this method is to determine, whether given role has the permission to perform certain *operation* with specific *resource*.

- **role** is a user attribute - for example moderator, editor, visitor, registered user, administrator, ...
- **resource** is a logical unit of the application - article, page, user, menu item, poll, presenter, ...
- **privilege** is a specific activity, which user may or may not do with *resource* - view, edit, delete, vote, ...


An implementation skeleton looks like this:

```php
class MyAuthorizator extends Nette\Object
	implements Nette\Security\IAuthorizator
{
	public function isAllowed($role, $resource, $privilege)
	{
		return ...; // returns either TRUE or FALSE
	}
}
```

And an example of use:

```php
// registers the authorizator
$user->setAuthorizator(new MyAuthorizator);

if ($user->isAllowed('file')) { // is user allowed to do everything with resource 'file'?
	useFile();
}

if ($user->isAllowed('file', 'delete')) { // is user allowed to delete a resource 'file'?
	deleteFile();
}
```

.[note]
Do not confuse two different methods `isAllowed`: one belongs to the authorizator and the other one to the `User` class, where the first argument is not `$role`.

Because the user may have many roles, he is granted permission only if at least one of roles has the permission. Both arguments are optional and their default value is *everything*.


Permission ACL
--------------
Nette Framework has a complete authorizator, class [api:Nette\Security\Permission] which offers a lightweight and flexible ACL((Access Control List)) layer for permission and access control. When we work with this class, we define roles, resources, and individual privileges. Roles and resources may form hierarchies, as shown in the following example:

- `guest`: visitor that is not logged in, allowed to read and browse public part of the web, ie. articles, comments, and to vote in a poll

- `registered`: logged-in user, which may on top of that post comments

- `administrator`: may write and administer articles, comments and polls

So we have defined certain roles (`guest`, `registered` and `administrator`) and mentioned resources (`article`, `comments`, `poll`), which the users may access or take actions on (`view`, `vote`, `add`, `edit`).

We create an instance of Permission and define user roles. As roles may inherit each other, we may, for example, specify that `administrator` may do the same as an ordinary visitor (and of course more).

```php
$acl = new Nette\Security\Permission;

// roles definition
$acl->addRole('guest');
$acl->addRole('registered', 'guest'); // registered inherits from guest
$acl->addRole('administrator', 'registered'); // and administrator inherits from registered
```

Trivial, isn't it? This ensures all the properties of the parents will be inherited by their children.

Do note the method `getRoleParents()`, which returns an array of all direct parent roles, and the method `roleIntheritsFrom()`, which checks whether a role extends another. Their usage:

```php
$acl->roleInheritsFrom('administrator', 'guest'); // TRUE
$acl->getRoleParents('administrator'); // array('registered') - only direct parents
```

Now is the right time to define the set of resources that the users may access:

```php
$acl->addResource('article');
$acl->addResource('comments');
$acl->addResource('poll');
```

Also resources may use inheritance. The API offers similar methods, only the names are slightly different: `resourceInheritsFrom()`, `removeResource()`.

And now the most important part. Roles and resources alone would do us no good, we have to create rules defining who can do what with whatever:

```php
// everything is denied now

// guest may view articles, comments and polls
$acl->allow('guest', array('article', 'comment', 'poll'), 'view');
$acl->allow('guest', 'poll', 'vote');

// registered user has also right to add comments
$acl->allow('registered', 'comment', 'add');

// administrator may also edit and add everything
$acl->allow('administrator', Permission::ALL, array('view', 'edit', 'add'));

// administrator cannot edit polls, that would be undemocractic.
$acl->deny('administrator', 'poll', 'edit');
```


What if we want to prevent someone ** particular resource access **?

```php

// administrators will not see ads
$acl->deny('administrator', 'ad', 'view');

```


Now when we have created the set of rules, we may simply ask the authorization queries:

```php
// can guest view articles?
$acl->isAllowed('guest', 'article', 'view'); // TRUE

// can guest edit an article?
$acl->isAllowed('guest', 'article', 'edit'); // FALSE
// may guest add comments?
$acl->isAllowed('guest', 'comments', 'add'); // FALSE
```

The same is TRUE for the registered user, though he is allowed to add a comment:

```php
$acl->isAllowed('registered', 'article', 'view'); // TRUE
$acl->isAllowed('registered', 'comments', 'add'); // TRUE
$acl->isAllowed('registered', 'backend', 'view'); // FALSE
```

Administrator is allowed to do everything:

```php
$acl->isAllowed('administrator', 'article', 'view'); // TRUE
$acl->isAllowed('administrator', 'commend', 'add'); // TRUE
$acl->isAllowed('administrator', 'poll', 'edit'); // FALSE
```

Admin rules may possibly be defined without any restrictions (without inheriting from any other roles):

```php
$acl->addRole('supervisor');
$acl->allow('supervisor');  // all privileges for all resources for supervisor
```

Whenever during the application runtime we may remove roles with `removeRolle()`, resources with `removeResource()` or rules with `removeAllow()` or `removeDeny()`.

Roles may inherit form one or more other roles. But what happens, if one ancestor has certain action allowed and the other one has it denied? Then the *role weight* comes into play - the last role in the array of roles to inherit has the greatest weight, first one the lowest:

```php
$acl = new Permission;
$acl->addRole('admin');
$acl->addRole('guest');

$acl->addResource('backend');

$acl->allow('admin', 'backend');
$acl->deny('guest', 'backend');

// example A: role admin has lower weight than role guest
$acl->addRole('john', array('admin', 'guest'));
$acl->isAllowed('john', 'backend'); // FALSE

// example B: role admin has greater weight than role guest
$acl->addRole('mary', array('guest', 'admin'));
$acl->isAllowed('mary', 'backend'); // TRUE
```


Usage in Application
====================

We can configure Permission in the configuration file like this:

```neon
services:
	acl:
		factory: Nette\Security\Permission
		setup:
			- addRole(admin)
			- addRole(guest)

			- addResource(backend)

			- allow(admin, backend)
			- deny(guest, backend)

			# example A: role admin has lower weight than role guest
			- addRole(john, [admin, guest])

			# example B: role admin has greater weight than role guest
			- addRole(mary, [guest, admin])
```

and then we can verify privileges in Presenter e.g. in the startup method:


```php
protected function startup()
{
	parent::startup();
	if (!$this->getUser()->isAllowed('backend')) {
		throw new Nette\Application\ForbiddenRequestException;
	}
}
```

The following solution is an alternative to the previous one. We create factory service, where we can setup Permission:

```php
namespace App\Model;

use Nette;

class AuthorizatorFactory extends Nette\Object
{
	/** @return Nette\Security\Permission */
	public static function create()
	{
		$acl = new Nette\Security\Permission;

		// if we want, we can load roles from database
		$acl->addRole('admin');
		$acl->addRole('guest');

		$acl->addResource('backend');

		$acl->allow('admin', 'backend');
		$acl->deny('guest', 'backend');

		// example A: role admin has lower weight than role guest
		$acl->addRole('john', array('admin', 'guest'));
		$acl->isAllowed('john', 'backend'); // FALSE

		// example B: role admin has greater weight than role guest
		$acl->addRole('mary', array('guest', 'admin'));
		$acl->isAllowed('mary', 'backend'); // TRUE

		return $acl;
	}
}
```

Then we have to register factory to the configuration file and use it as factory for Permission:

```neon
services:
	#  class Permission will be created by calling create method in AuthorizationFactory
	- App\Model\AuthorizatorFactory::create
```


{{composer: nette/security}}
