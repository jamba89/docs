Ověřování oprávnění (Autorizace)
********************************

.[perex]
Autorizace zjišťuje, zda má uživatel dostatečná oprávnění například pro přístup k určitému zdroji či pro provedení nějaké akce. Autorizace předpokládá předchozí úspěšnou autentizaci, tj. že uživatel je přihlášen.

V příkladech budeme používat objekt třídy [api:Nette\Security\User], který představuje aktuálního uživatele a ke kterému se dostanete tak, že si jej necháte předat pomocí dependency injection. V presenterech stačí jen zavolat `$user = $this->getUser()`.

Autorizace se může v Nette Framework vyhodnocovat na základě členství uživatele v určitých skupinách či přidělených rolích. Začněme ale od úplného začátku.


U jednoduchých webů s administrací, kde se nerozlišují různá oprávnění uživatelů, je možné jako autorizační kritérium použít již známou metodu `isLoggedIn()`. Řečeno srozumitelnějším jazykem: jakmile je uživatel přihlášen, má veškerá oprávnění a naopak.

```php
if ($user->isLoggedIn()) { // je uživatel přihlášen?
	deleteItem(); // pak má k operaci oprávnění
}
```


Role
----

Smyslem rolí je nabídnout přesnější řízení oprávnění, ale zůstat nezávislý na uživatelském jméně. Každému uživateli hned při přihlášení přiřkneme jednu či více rolí, ve kterých bude vystupovat. Role mohou být pojmenovány například `admin`, `member`, `guest`, apod. Uvádí se jako druhý parametr konstruktoru `Identity`, buď jako řetězec nebo pole řetězců - rolí.

Jako autorizační kritérium nyní použijeme metodu `isInRole()`, která prozradí, zda uživatel vystupuje v dané roli:

```php
if ($user->isInRole('admin')) { // je uživatel v roli admina?
	deleteItem(); // pak má k operaci oprávnění
}
```

Jak už víte, po odhlášení uživatele se nemusí smazat jeho identita. Tedy i nadále metoda `getIdentity()` vrací objekt `Identity`, včetně všech udělených rolí. Nette Framework vyznávající princip „less code, more security“, kdy méně psaní vede k více zabezpečenému kódu, nechce nutit programátora všude psát `if ($user->isLoggedIn() && $user->isInRole('admin'))` a proto metoda `isInRole()` pracuje s **efektivními rolemi.** Pokud je uživatel přihlášen, vychází z rolí uvedených v identitě, pokud přihlášen není, má automaticky speciální roli `guest`.


Autorizátor
-----------

Autorizátor je ten, kdo umí rozhodnout, zda má uživatel oprávnění provést určitou akci. Jde o objekt implementující rozhraní [api:Nette\Security\IAuthorizator] s jedinou metodu `isAllowed()`, jejímž úkolem je rozhodnout, zda má daná *role* povolení provést určitou *operaci* s určitým *zdrojem*.

- **role** je vlastnost uživatele - např. moderátor, redaktor, návštěvník, zaregistrovaný uživatel, správce...
- **zdroj** (*resource*) je nějaký logický prvek webu - článek, stránka, uživatel, položka v menu, anketa, presenter, ...
- **operace** (*privilege*) je nějaká konkrétní činnost, kterou uživatel může či nemůže se zdrojem dělat - například smazat, upravit, vytvořit, hlasovat, ...

Rámcová podoba implementace vypadá takto:

```php
class MyAuthorizator extends Nette\Object
	implements Nette\Security\IAuthorizator
{
	public function isAllowed($role, $resource, $privilege)
	{
		return ...; // vrací TRUE nebo FALSE
	}
}
```

A následuje příklad použití:

```php
// zaregistrujeme autorizátor
$user->setAuthorizator(new MyAuthorizator);

if ($user->isAllowed('file')) { // může uživatel dělat cokoliv se zdrojem 'file'?
	useFile();
}

if ($user->isAllowed('file', 'delete')) { // může nad zdrojem 'file' provést 'delete'?
	deleteFile();
}
```

.[note]
Nezaměňujte si dvě různé metody `isAllowed`: jedna patří autorizátoru, druhá třídě User, kde už není první parametr `$role`.

Protože uživatel může vystupovat ve více rolích, povolení dostane, pokud alespoň jedna role má povolení. Oba parametry jsou volitelné, výchozí hodnota nese význam *všechny*.


Permission ACL
--------------

Nette Framework disponuje předpřipravenou implementací autorizátoru, a to třídou [api:Nette\Security\Permission] poskytující programátorovi lehkou a flexibilní ACL((Access Control List)) vrstvu pro řízení práv a přístupu. Práce s ní spočívá v definici rolí, zdrojů a jednotlivých oprávnění. Přičemž role a zdroje umožňují vytvářet hierarchie. Na vysvětlenou si ukážeme příklad webové aplikace:

- `guest`: nepřihlášený návštěvník, který může číst a procházet veřejnou část webu, tzn. číst články, komentáře a volit v anketách

- `registered`: přihlášený registrovaný uživatel, který navíc může komentovat

- `administrator`: může psát a spravovat články, komentáře i ankety

Nadefinovali jsme si tedy určité role (`guest`, `registered` a `admin`) a zmínili zdroje (`article`, `comment`, `poll`), ke kterým mohou uživatelé s nějakou rolí přistupovat nebo provádět určité operace (`view`, `vote`, `add`, `edit`).

Vytvoříme instanci třídy Permission a nadefinujeme uživatelské role. Lze přitom využít tzv. dědičnost rolí, která zajistí, že např. uživatel s rolí `administrátor` může dělat i to co obyčejný návštěvník webu (a samozřejmě i více).

```php
$acl = new Nette\Security\Permission;

// definujeme role
$acl->addRole('guest');
$acl->addRole('registered', 'guest'); // registered dědí od guest
$acl->addRole('administrator', 'registered'); // a od něj dědí administrator
```

Docela triviální že? Tímto zajistíme, že se nám vlastnosti budou přenášet z rodičovské role na potomky.

Za zmínku stojí metoda `getRoleParents()`, která vrací pole se všemi přímými rodičovskými rolemi a také metoda `roleInheritsFrom()`, která zjistí, zda od sebe dědí dvě role. Jejich použití:

```php
$acl->roleInheritsFrom('administrator', 'guest'); // TRUE
$acl->getRoleParents('administrator'); // array('registered')
```

Nyní je čas nadefinovat i **seznam zdrojů, ke kterým mohou uživatelé přistupovat**.

```php
$acl->addResource('article');
$acl->addResource('comment');
$acl->addResource('poll');
```

I zdroje/objekty mohou používat dědičnost. Metody pro dotazování se na hierarchii zdrojů jsou podobné jako u rolí, liší se jen názvy: `resourceInheritsFrom()`, `removeResource()`.

.[tip]
Role i zdroje můžeme nastavit také pomocí konfiguračního souboru.

A teď to nejdůležitější. Samotné role a objekty by nám byly k ničemu, musíme mezi nimi vytvořit ještě **pravidla, určující, kdo co může s čím dělat**:


```php
// nejprve nikdo nemůže dělat nic

// nechť guest může prohlížet obsah veřejné části, hlasovat v anketách
$acl->allow('guest', array('article', 'comment', 'poll'), 'view');
$acl->allow('guest', 'poll', 'vote');

// registrovaný dědí právo od guesta, ale má i právo komentovat
$acl->allow('registered', 'comment', 'add');

// administrátor může prohlížet a editovat cokoliv
$acl->allow('administrator', Permission::ALL, array('view', 'edit', 'add'));
```

Co když chceme někomu **zamezit do určitého zdroje přístup**?

```php

// administrátoři neuvidí reklamy
$acl->deny('administrator', 'ad', 'view');

```


Nyní když máme vytvořený seznam pravidel, můžeme jednoduše klást autorizační dotazy:

```php
// může guest prohlížet články?
$acl->isAllowed('guest', 'article', 'view'); // TRUE
// může guest editovat články?
$acl->isAllowed('guest', 'article', 'edit'); // FALSE
// může guest hlasovat v anketách?
$acl->isAllowed('guest', 'poll', 'vote'); // TRUE
// může guest komentovat?
$acl->isAllowed('guest', 'comment', 'add'); // FALSE
```

Totéž platí pro registrovaného uživatele, ten však komentovat už může:

```php
$acl->isAllowed('registered', 'article', 'view'); // TRUE
$acl->isAllowed('registered', 'comment', 'add'); // TRUE
$acl->isAllowed('registered', 'backend', 'view'); // FALSE
```

Administrátor může editovat vše:

```php
$acl->isAllowed('administrator', 'poll', 'vote'); // TRUE
$acl->isAllowed('administrator', 'poll', 'edit'); // TRUE
$acl->isAllowed('administrator', 'comment', 'edit'); // TRUE
```

Práva administrátora lze nadefinovat i bez omezení tzn. bez rodičů, od kterých by dědil nějaká omezení. Vypadalo by to asi takto:

```php
$acl->addRole('supervisor');
$acl->allow('supervisor');  // všechna práva a zdroje pro administrátora
```

Kdykoliv za běhu aplikace můžeme i odebrat roli metodou `removeRole()`, zdroj odebere `removeResource()`, pravidlo `removeAllow()` nebo `removeDeny()`.

Role může dědit od jiné role či od více rolí. Co se ale stane, pokud má jeden předek akci zakázanou a druhý povolenou? Jaké budou práva potomka? Určuje se to podle váhy role - poslední uvedená role v seznamu předků má největší váhu, první uvedená role tu nejmenší. Více názorné je to z příkladu:

```php
$acl = new Permission;
$acl->addRole('admin');
$acl->addRole('guest');

$acl->addResource('backend');

$acl->allow('admin', 'backend');
$acl->deny('guest', 'backend');

// případ A: role admin má menší váhu než role guest
$acl->addRole('john', array('admin', 'guest'));
$acl->isAllowed('john', 'backend'); // FALSE

// případ B: role admin má větší váhu než guest
$acl->addRole('mary', array('guest', 'admin'));
$acl->isAllowed('mary', 'backend'); // TRUE
```


Použití v aplikaci
==================

Permission můžeme nakonfigurovat v konfiguračním souboru následujícím způsobem:

```neon
services:
	acl:
		factory: Nette\Security\Permission
		setup:
			- addRole(admin)
			- addRole(guest)

			- addResource(backend)

			- allow(admin, backend)
			- deny(guest, backend)

			# případ A: role admin má menší váhu než role guest
			- addRole(john, [admin, guest])

			# případ B: role admin má větší váhu než guest
			- addRole(mary, [guest, admin])
```

a v presenterech pak můžete ověřit práva například v metodě startup:


```php
protected function startup()
{
	parent::startup();
	if (!$this->getUser()->isAllowed('backend')) {
		throw new Nette\Application\ForbiddenRequestException;
	}
}
```

Alternativou k nastavení v konfiguračním souboru je vytvoření továrny, která nám Permission nastaví. Ta pak může vypadat například následovně:

```php
namespace App\Model;

use Nette;

class AuthorizatorFactory extends Nette\Object
{
	/** @return Nette\Security\Permission */
	public static function create()
	{
		$acl = new Nette\Security\Permission;

		// pokud chceme, můžeme role a zdroje načíst z databáze
		$acl->addRole('admin');
		$acl->addRole('guest');

		$acl->addResource('backend');

		$acl->allow('admin', 'backend');
		$acl->deny('guest', 'backend');

		// případ A: role admin má menší váhu než role guest
		$acl->addRole('john', array('admin', 'guest'));
		$acl->isAllowed('john', 'backend'); // FALSE

		// případ B: role admin má větší váhu než guest
		$acl->addRole('mary', array('guest', 'admin'));
		$acl->isAllowed('mary', 'backend'); // TRUE

		return $acl;
	}
}
```

Tovární metodu použijeme jako továrnu pro Permission:

```neon
services:
	# třídu Permission vytvoříme metodou create třídy AuthorizatorFactory
	- App\Model\AuthorizatorFactory::create
```


{{composer: nette/security}}
